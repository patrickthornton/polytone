# Polytone Design

Overall, this project ended up using web design languages only - HTML, CSS, and pure JavaScript. Turns out that the big crux of the project (pure oscillators) was already supported by JavaScript and its web audio API, thankfully. This made for a lot of JavaScript programming, but the end result is slim and fast enough to make me happy.

## tones.js

Each of the three JavaScript files reference eachother pretty continuously, and are placed right next to one another in the HTML - their separation is just a device to keep things organized while working. I'll talk about their design one by one, referencing the HTML and CSS as needed. First, tones.js; this is the core of the site, where the 'tones' get made. While JavaScript's web audio API has a lot of features which are nice for generating multiple sounds at once (i.e., the AudioContext and DynamicsCompressorNode apply to as many sounds as they need to), I still ran into what will become a recurring problem for this project; what's the smartest way to code for six identical operators at once, without the code becoming six times as long?

At the bottom of the document is the best answer I had; I created a class to bunch together all of the elements I needed for each oscillator, writing functions which apply generally using the keyword 'this', which I could later reference using the specific document elements for each oscillator. In tones.js, we see exactly that; six nearly identical functions which monitor the 'play/stop' button (I found that making this one button which toggles rather than two aligned with the pause/play buttons of music apps elsewhere), referencing a couple general prototypes on a Tone object which represents one whole oscillator. The only other tricky thing here is the specific JavaScript functions for AudioParam objects, like setTargetAtTime or exponentialRampToValueAtTime. The exact values for these were found by hand; I was trying to strike the balance between quick, clean sound cutoffs and low audio glitching.

## slider.js

I know I promised GET functionality, but that ended up being too much of a hassle for a very low payoff; instead, I spent a whole lot of time here, coding the exact inner workings of the frequency slider. This is probably the heaviest JavaScript file; I'll go bottom to top.

At the bottom is another general class to reference in specific cases. This time, it's a class detailing the exact workings of an exponential slider. The challenge is to map the 5000 positions of a slider such that position 1 maps to 20 Hz, position 5000 maps to 20000 Hz, and everything in between is given a properly fitting exponential function. Some calculus later, and this is the result. It still wasn't perfect, since it resulted in just about 1500 of 5000 slider positions dedicated to infrasound frequencies noone can hear (1-20 Hz), so I manually changed the slider's minimum to that position which results in a frequency of 20 Hz. This cuts the number of positions on the slider down, but the end result still appears plenty smooth to me.

Above those expSlider functions are what I'll call the 'cross-referencing functions'. These keep each part of an oscillator - hz slider, hz value input box, wave type, gain slider, pitch entry, times factor - all continually updated with one another. If we didn't generalize it like this, the sea of functions above this for each oscillator would become even more redundant and obfuscatory. Note that each of these functions reference methods from tones.js. Also. each of these functions has numerous stipulations to prevent errors, like disallowed Hz values or preventing non-numbers from being interpreted as numbers. Most are self-explanatory, but the timesShift function was tricky, mainly because the function I needed (one that could process decimal or fractional number inputs) seemed to be eval(). But the programming community at large quickly shut down that idea, with warnings of eval()'s security flaws and sluggish tendencies. So I had to brute-force fractional input processing.

At the top of the file are the six blocks of functions for each individual oscillator, referencing the general functions described above. I've tried to keep things clean and only pull an element from the document and store it as a variable once across all the JavaScript; here's where most of the heavy lifting is done. This does provide the advantage of keeping the HTML as repetitive as possible; once the generalization was done, a lot of coding the extra oscillators came down to copy-pasting and find-and-replacing numbers, which I actually took as a good sign that I'd reduced each oscillator to essentially the same procedure. Note that we use oninput for some elements and onchange for others; onchange was best for the text inputs since it doesn't go into effect until a user hits 'Enter' or clicks somewhere else. Otherwise, if you changed 400 Hz to 500 Hz, you'd have to hear the oscillator try and go to 40 Hz, 4 Hz, 0 Hz, 5 Hz, and 50 Hz in between.

(You can also see the lost window.onload function; this would often cause all of the sliders to twitch upon the page loading, so it ended up being better to hard-code the function results into the attributes in the HTML itself.)

## notes.js

Here's where the equal-temperament pitch input feature is implemented. Right at the top is the crown jewel; an actual calculation of an equally tempered pitch, given a number of half-steps away from a given reference pitch. (The formula's actually pretty simple.) I could have hard-coded the equal-tempered notes in, but then the reference pitch feature wouldn't work; besides, this is more accurate.

Besides that, we have functions monitoring the pitch input text box for changes, and then one big generalized function which interprets any written note, say 'c4', and calculates the number of half-steps it is away from a4 before running the above equal temperament calculation. I could have tried to find some clunky way to let a user choose from 90+ different pitches, but this seems to be a lot faster and visually cleaner. This involves a lot of string processing and a lot of checks for misinputs, as it most likely has to.

Further down, we have the function allowing for users to turn off/on all the oscillators at once with 'p'. Space and Enter both could have been used in the text boxes, and while that would have been a mistake, I didn't want all of the oscillators cranking on accidentally. (The choice to usually use .oninput or .onchange instead of a ton of EventListeners was purely force of habit; I think the former looks cleaner, but that's just superficial.) Finally, we have a function which simulates a pitch change for all 6 tones when ref is changed; this seemed like a slimmer way to do this, as the alternative was to change all of the previous cross-referencing functions to include it.

## layout
The visual design is pretty minimal and hopefully easy to look at - I am not inclined towards visual art, as it were. The layout is a little large, meaning that mobile users will probably have to do some scrolling, but I did make sure that the scroll always works no matter how small your screen is. Since the body is at the top left, and objects stretch down far enough, you'll always be able to reach all 6 oscillators. Regardless, it does look best all laid out on a laptop-sized screen. (Besides, phone speakers would have a tough time with six oscillators anyway.)

The CSS includes the only piece of code I totally grabbed off the internet - a slider demo from w3schools. Most of the parameters have been adjusted after the fact, though. I tried to use the 'cascading' in CSS as much as possible, but some kinks had to be ironed out.

Besides that, I tried to put some meta information in the HTML, but any advice as to how to make this a better website as far as websites go would be much appreciated. (Was there a way to enable gzip compression using CS50 IDE? Because I couldn't figure it out.) That's all - thanks so much for the semester!